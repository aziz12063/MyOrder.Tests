using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
//using System.Diagnostics;
using System.Linq;
using System.Text;

namespace MyOrder.Generator;

[Generator(LanguageNames.CSharp)]
public class FieldReducersGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        //Debugger.Launch();
        // Pick out every type with our marker attribute
        var candidates =
            context.SyntaxProvider.ForAttributeWithMetadataName(
                "MyOrder.Generator.GenerateFieldReducersAttribute",
                predicate: static (n, _) => n is TypeDeclarationSyntax,
                transform: static (context, _) =>
                    (Node: (TypeDeclarationSyntax)context.TargetNode,
                     Symbol: (INamedTypeSymbol)context.TargetSymbol));

        // We need the compilation later for type checks
        var pipeline = context.CompilationProvider.Combine(candidates.Collect());

        context.RegisterSourceOutput(
            candidates.Collect(),
            static (spc, slices) => Execute(slices, spc));
    }

    private static void Execute(
        ImmutableArray<(TypeDeclarationSyntax _, INamedTypeSymbol Symbol)> slices,
        SourceProductionContext spc)
    {
        foreach (var (_, sliceSym) in slices)
        {
            // Collect all IField-implementing properties (including nested)
            var matches = new List<FieldMatch>();
            CollectFieldProps(
                sliceSym,
                ImmutableStack<string>.Empty,
                matches,
                new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default),
                spc);

            if (matches.Count == 0) continue;

            var nsName = sliceSym.ContainingNamespace.ToDisplayString();
            var slice = sliceSym.Name;
            var src = RenderReducer(nsName, slice, matches);

            spc.AddSource($"{slice}.FieldReducers.g.cs",
                          SourceText.From(src, Encoding.UTF8));
        }
    }

    private static void CollectFieldProps(
        INamedTypeSymbol type,
        ImmutableStack<string> path,
        List<FieldMatch> sink,
        HashSet<INamedTypeSymbol> seen,
        SourceProductionContext spc)
    {
        if (!seen.Add(type))
            return;

        foreach (var prop in type.GetMembers().OfType<IPropertySymbol>())
        {
            if (prop.IsIndexer || IsDisplayOnly(prop))
                continue;

            if (ImplementsIField(prop.Type))
            {
                sink.Add(new FieldMatch(prop, path, IsInList: false));
                continue;
            }

            if (IsImmutableList(prop.Type, out var elemType))
            {
                foreach (var inner in elemType.GetMembers()
                                              .OfType<IPropertySymbol>()
                                              .Where(p => ImplementsIField(p.Type)
                                              && !IsDisplayOnly(p)))
                {
                    sink.Add(new FieldMatch(
                        inner,
                        path.Push(prop.Name),
                        IsInList: true));
                }
                continue;
            }

            if (prop.Type is INamedTypeSymbol nts
                && nts.TypeKind == TypeKind.Class
                && !nts.IsImplicitlyDeclared)
            {
                CollectFieldProps(nts,
                                  path.Push(prop.Name),
                                  sink, seen, spc);
                continue;
            }
        }

    }

    private static string RenderReducer(
    string ns, string slice, IReadOnlyList<FieldMatch> matches)
    {
        var sb = new StringBuilder($$"""
// <auto-generated/>
using Fluxor;
using MyOrder.Store.ProcedureCallUseCase;

namespace {{ns}};

public static partial class {{slice}}FieldReducers
{
    /// <summary>
    /// Optimistic in-memory update of a single <see cref="IField"/>.
    /// Generated by <see cref="MyOrder.Generator.FieldReducersGenerator"/> at {{DateTime.Now}}.
    /// </summary>
    [ReducerMethod]
    public static {{slice}} ReduceUpdateField({{slice}} state,
                                UpdateFieldAction a)
    {
""");
        // slice-status guard  (always emitted)
        sb.AppendLine("        // slice not ready – abort fast");
        sb.AppendLine("        if (!state.Initialized || state.IsLoading || state.IsFaulted)");
        //sb.AppendLine("        if (!state.Initialized || state.IsFaulted)");
        sb.AppendLine("            return state;");
        sb.AppendLine();

        // deep-null guard  (only if there is at least one list element match)
        if (matches.Any(m => m.IsInList))
        {
            var listPath = matches.First(m => m.IsInList).Path;
            var guard = $$"""
            if ({{PathToAccessor("state", listPath)}} is not { } _) return state;
            """;

            sb.AppendLine("        // list is null – nothing to update");
            sb.AppendLine($"        {guard}");
            sb.AppendLine();
        }

        foreach (var m in matches)
        {
            if (m.IsInList)
            {
                // collection-element branch already contains its own if/return
                sb.AppendLine(BuildEditExpression("state", m));
                continue;
            }

            var test = BuildReferenceCheck("state", m);
            var edit = BuildEditExpression("state", m);
            sb.AppendLine();
            sb.AppendLine($"        if ({test})");
            sb.AppendLine($"            return {edit};");
        }

        sb.AppendLine();
        sb.AppendLine("""
        return state; // not my field
    }
}
""");
        return sb.ToString();
    }

    /*──────────────────────────────────────────────*/
    /* Builders                                     */
    /*──────────────────────────────────────────────*/

    private static string BuildReferenceCheck(string root, FieldMatch m)
    {
        var access = PathToAccessor(root, m.Path, m.Property.Name);
        return $"ReferenceEquals({access}, a.Field)";
    }

    private static string BuildEditExpression(string root, FieldMatch m)
    {
        // ── scalar or nested record field ─────────────────────────
        if (!m.IsInList)
        {
            var accessor = PathToAccessor(root, m.Path, m.Property.Name);
            var updated = $"{accessor} with {{ Value = a.Value }}";
            return WrapWithChain(root, m.Path, m.Property.Name, updated);
        }
        // ── field inside ImmutableList element ────────────────────
        var listProp = m.Path.Peek();
        var parentPath = m.Path.Pop();

        var listAcc = PathToAccessor(root, m.Path);
        var iVar = "__i";
        var itemVar = "__item";

        var updatedElement = WrapWithChain(itemVar,
            ImmutableStack<string>.Empty,
            m.Property.Name,
            $"{itemVar}.{m.Property.Name} with {{ Value = a.Value }}",
            formatInner: true,
            indent: 0,
            rootLevel: false);

        var replace =
            $"{listAcc}.SetItem({iVar}, {Indent(updatedElement, 8).TrimStart()})";

        // Outer chain back to the slice root, pretty-print inner
        var body = WrapWithChain(root,
                                 parentPath,
                                 listProp,
                                 replace,
                                 formatInner: true);


        var loop =
$@"
for (var {iVar} = 0; {iVar} < {listAcc}.Count; {iVar}++)
{{
    var {itemVar} = {listAcc}[{iVar}];
    if (ReferenceEquals({itemVar}.{m.Property.Name}, a.Field))
        return {body};
}}
";
        return Indent(loop);
    }

    private static string WrapWithChain(
    string root,
    ImmutableStack<string> path,
    string leaf,
    string innerExpr,
    bool formatInner = false,
    int indent = 12,
    bool rootLevel = true)    // NEW flag (default true)
    {
        // pretty-print the inner expression if requested
        var inner = formatInner && innerExpr.Contains(" with ")
            ? "\n" + Indent(innerExpr, indent + 8) +
              "\n" + new string(' ', indent + 4)
            : innerExpr;

        var segments = path.Reverse().ToArray();          // outer → inner
        var sb = new StringBuilder();
        var pad = new string(' ', indent);

        /* first line */
        sb.AppendLine($"{root} with");
        sb.AppendLine($"{pad}{{");

        // INSERT FLAG only for the very first (slice-level) call
        if (rootLevel)
            sb.AppendLine($"{pad}    IsLoading = true,");

        string current = root;
        for (int i = 0; i < segments.Length; i++)
        {
            var seg = segments[i];
            pad = new string(' ', indent + (i + 1) * 4);

            sb.AppendLine($"{pad}{seg} = {current}.{seg} with");
            sb.AppendLine($"{pad}{{");

            current += $".{seg}";
        }

        /* leaf assignment */
        pad = new string(' ', indent + (segments.Length + 1) * 4);
        sb.AppendLine($"{pad}{leaf} = {inner}");

        /* close braces */
        for (int i = segments.Length; i >= 0; i--)
        {
            pad = new string(' ', indent + i * 4);
            sb.AppendLine($"{pad}}}");
        }

        return sb.ToString().TrimEnd();
    }



    /*──────────────────────────────────────────────*/
    /* Helper record                                */
    /*──────────────────────────────────────────────*/
    private sealed record FieldMatch(
        IPropertySymbol Property,
        ImmutableStack<string> Path,
        bool IsInList);

    /*──────────────────────────────────────────────*/
    /* Helpers methods                              */
    /*──────────────────────────────────────────────*/
    private static bool ImplementsIField(ITypeSymbol t) =>
        t.AllInterfaces.Any(i => i.Name == "IField");

    private static bool IsDisplayOnly(IPropertySymbol prop)
    {
        static bool HasAttr(IEnumerable<AttributeData> attrs) =>
            attrs.Any(a => a.AttributeClass?.Name is "DisplayOnlyFieldAttribute");

        var result = HasAttr(prop.GetAttributes()) ||
               HasAttr(prop.ContainingType.GetAttributes());
        return result;
    }

    private static bool IsImmutableList(ITypeSymbol t, out INamedTypeSymbol elem)
    {
        elem = null!;
        return t is INamedTypeSymbol nts
            && nts.Name == "ImmutableList"
            && nts.ContainingNamespace.ToDisplayString() == "System.Collections.Immutable"
            && nts.TypeArguments.Length == 1
            && (elem = nts.TypeArguments[0] as INamedTypeSymbol) is not null;
    }

    private static string Indent(string text, int spaces = 8)
    {
        const string NL = "\r\n";
        var pad = new string(' ', spaces);
        var lines = text.Split('\n');
        return string.Join(NL, lines.Select(l => pad + l.TrimEnd()));
    }

    private static string PathToAccessor(
        string root, ImmutableStack<string> path, string propName)
    {
        var parts = path.Reverse().Select(p => "." + p).ToList();
        parts.Add("." + propName);
        return root + string.Concat(parts);
    }

    private static string PathToAccessor(string root, ImmutableStack<string> path) =>
        root + string.Concat(path.Reverse().Select(p => "." + p));

}