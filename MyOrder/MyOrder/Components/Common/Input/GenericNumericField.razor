@* We should use (where T : INumber<T>) but the latter doesn't accept nullable *@
@typeparam T
@using System.Globalization
@using MyOrder.Services
@inject ICurrencyService Currency
@inherits GenericInputBase<T>

@if (Field is not null && !Hidden)
{
    <MudTooltip RootStyle="width:100%"
                Text="@TooltipText"
                Placement="Placement.Top">
        <MudNumericField @ref="_mudNumericField"
                         T="T"
                         Adornment="_isFormatPercentValue ? Adornment.End: Adornment.None"
                         AdornmentText="@(_isFormatPercentValue ? "%" : null)"
                         Class="@Class"
                         Style="@(_isFormatPercentValue ? $"text-align-last : end; {Style}" : Style)"
                         Typo="Typo.subtitle2"
                         Label="@FieldLabel()"
                         Margin="Margin"
                         Variant="@Variant"
                         Underline="!HideLabel"
                         FullWidth="true"
                         Required="Required"
                         Error="Error"
                         ReadOnly="InternalReadOnly || OnlyForDisplay"
                         Disabled="InternalReadOnly || OnlyForDisplay"
                         Format="@(_isFormatPercentValue ? null : Format)"
                         Culture="@Culture"
                         Value="ValueProperty"
                         ValueChanged="OnValueChanged"
                         Clearable="Clearable"
                         Min="Min"
                         Step="Step"
                         HideSpinButtons="InternalReadOnly || HideSpinButton"
                         OnKeyDown="KeyDownHandler" />
    </MudTooltip>
}
@code {
    [Parameter]
    public T Step { get; set; }
    [Parameter]
    public T Min { get; set; }
    [Parameter]
    public Variant Variant { get; set; } = Variant.Text;
    [Parameter]
    public string Class { get; set; } = string.Empty;
    [Parameter]
    public string Style { get; set; } = string.Empty;
    [Parameter]
    public bool Clearable { get; set; } = false;
    [Parameter]
    public string? Format { get; set; }
    [Parameter]
    public bool HideSpinButton { get; set; } = false;
    [Parameter]
    public EventCallback<KeyboardEventArgs> OnKeyDown { get; set; }

    private CultureInfo? Culture { get; set; }

    private MudNumericField<T> _mudNumericField = null!;
    private Type _underLyingType = GetUnderlyingType(typeof(T));
    private bool _isFormatPercentValue;

    protected override void OnInitialized()
    {
        base.OnInitialized();
        Culture = Currency.GetCurrency();
        if (!IsNumericType(_underLyingType))
        {
            throw new InvalidOperationException($"The type '{_underLyingType}' is not a numeric type.");
        }
        if (Step is null)
            Step = ConvertTo(1);
        if (Min is null)
            Min = (T)GetMinValue(_underLyingType);
    }
    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        _isFormatPercentValue = Format?.Equals("P", StringComparison.OrdinalIgnoreCase) ?? false;

        if (Variant == Variant.Outlined)
            Class += " outlined-generic-textfield";
    }

    private async Task KeyDownHandler(KeyboardEventArgs e)
    {
        await OnKeyDown.InvokeAsync(e);
    }

    private async Task OnValueChanged(T newValue)
    {
        if (EqualityComparer<T>.Default.Equals(newValue, ValueProperty))
            return;

        await _mudNumericField.Validate();

        var totalValidationErrors = _mudNumericField.ValidationErrors.Count;

        if (totalValidationErrors == 0)
        {
            ValueChangedHandler(newValue);
            await _mudNumericField.BlurAsync();
        }
    }

    private static bool IsNumericType(Type underLyingType)
    {
        if (underLyingType.IsEnum)
            return false;

        switch (Type.GetTypeCode(underLyingType))
        {
            case TypeCode.Byte:
            case TypeCode.SByte:
            case TypeCode.UInt16:
            case TypeCode.UInt32:
            case TypeCode.UInt64:
            case TypeCode.Int16:
            case TypeCode.Int32:
            case TypeCode.Int64:
            case TypeCode.Decimal:
            case TypeCode.Double:
            case TypeCode.Single:
                return true;
            default:
                return false;
        }
    }

    private static T ConvertTo(object value)
    {
        var type = typeof(T);
        var targetType = Nullable.GetUnderlyingType(type) ?? type;

        if (value == null || value == DBNull.Value)
        {
            return default;
        }

        return (T)Convert.ChangeType(value, targetType);
    }

    private static object GetMinValue(Type type) => type switch
    {
        Type t when t == typeof(float) => float.MinValue,
        Type t when t == typeof(double) => double.MinValue,
        Type t when t == typeof(decimal) => decimal.MinValue,
        Type t when t == typeof(int) => int.MinValue,
        Type t when t == typeof(long) => long.MinValue,
        Type t when t == typeof(sbyte) => sbyte.MinValue,
        Type t when t == typeof(byte) => byte.MinValue,
        Type t when t == typeof(short) => short.MinValue,
        Type t when t == typeof(ushort) => ushort.MinValue,
        Type t when t == typeof(uint) => uint.MinValue,
        Type t when t == typeof(ulong) => ulong.MinValue,
        _ => throw new ArgumentException($"Unsupported type {type}")
    };

    private static Type GetUnderlyingType(Type type) =>
    Nullable.GetUnderlyingType(type) ?? type;
}