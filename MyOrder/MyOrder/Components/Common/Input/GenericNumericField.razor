@* We should use (where T : INumber<T>) but the latter doesn't accept nullable *@
@typeparam T

@inherits GenericInputBase<T>

@if (Field is not null && !_hidden)
{
    <MudTooltip RootStyle="width:100%"
                Text="@_tooltipText"
                Placement="Placement.Top">
        <MudNumericField T="T"
                         Typo="Typo.body2"
                         Label="@FieldLabel()"
                         Margin="Margin.Dense"
                         Variant="@Variant"
                         Underline="!HideLabel"
                         FullWidth="true"
                         Required="_required"
                         Error="_required"
                         ReadOnly="_readOnly"
                         Disabled="_readOnly"
                         @bind-value="ValueProperty"
                         @bind-value:after="OnBindValueAfter"
                         Clearable="Clearable"
                         Min="Min"
                         Step="Step"
                         HideSpinButtons="false" />
    </MudTooltip>
}

@code {
    [Parameter]
    public T Step { get; set; }
    [Parameter]
    public T? Min { get; set; }
    [Parameter]
    public Variant Variant { get; set; } = Variant.Text;
    [Parameter]
    public bool Clearable { get; set; } = false;

    private Type _underLyingType = GetUnderlyingType(typeof(T));

    protected override void OnInitialized()
    {
        base.OnInitialized();

        if (_underLyingType != typeof(int) && _underLyingType != typeof(short) && _underLyingType != typeof(decimal) &&
            _underLyingType != typeof(long) && _underLyingType != typeof(float) && _underLyingType != typeof(double) &&
            _underLyingType != typeof(byte) && _underLyingType != typeof(sbyte) && _underLyingType != typeof(uint) &&
            _underLyingType != typeof(ushort) && _underLyingType != typeof(ulong))
        {
            throw new InvalidOperationException($"The type '{_underLyingType}' is not a numeric type.");
        }
        if (Step is null)
            Step = ConvertTo(1);
        if (Min is null)
            Min = (T)GetMinValue(_underLyingType);
    }

    private static T ConvertTo(object value)
    {
        var type = typeof(T);
        var targetType = Nullable.GetUnderlyingType(type) ?? type;

        if (value == null || value == DBNull.Value)
        {
            return default;
        }

        return (T)Convert.ChangeType(value, targetType);
    }

    private static object GetMinValue(Type type) => type switch
    {
        Type t when t == typeof(float) => float.MinValue,
        Type t when t == typeof(double) => double.MinValue,
        Type t when t == typeof(decimal) => decimal.MinValue,
        Type t when t == typeof(int) => int.MinValue,
        Type t when t == typeof(long) => long.MinValue,
        Type t when t == typeof(sbyte) => sbyte.MinValue,
        Type t when t == typeof(byte) => byte.MinValue,
        Type t when t == typeof(short) => short.MinValue,
        Type t when t == typeof(ushort) => ushort.MinValue,
        Type t when t == typeof(uint) => uint.MinValue,
        Type t when t == typeof(ulong) => ulong.MinValue,
        _ => throw new ArgumentException($"Unsupported type {type}")
    };

    private static Type GetUnderlyingType(Type type) =>
    Nullable.GetUnderlyingType(type) ?? type;
}