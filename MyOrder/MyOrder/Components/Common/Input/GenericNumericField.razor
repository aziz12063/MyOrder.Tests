@* We should use (where T : INumber<T>) but the latter doesn't accept nullable *@
@typeparam T
@using System.Globalization
@using MyOrder.Services
@inject ICurrencyService Currency
@inherits GenericInputBase<T>

@if (Field is not null && !Hidden)
{
    <MudTooltip RootStyle="width:100%"
                Text="@TooltipText"
                Placement="Placement.Top">
        <MudNumericField T="T"
                         Typo="Typo.body2"
                         Label="@FieldLabel()"
                         Margin="Margin.Dense"
                         Variant="@Variant"
                         Underline="!HideLabel"
                         FullWidth="true"
                         Required="Required"
                         Error="Required"
                         ReadOnly="InternalReadOnly"
                         Disabled="InternalReadOnly"
                         Format="@Format"
                         Culture="@Culture"
                         Value="ValueProperty"
                         ValueChanged="OnValueChanged"
                         Text="@_displayedValue"
                         Clearable="Clearable"
                         Min="Min"
                         Step="Step"
                         HideSpinButtons="false" />
    </MudTooltip>
}

@code {
    [Parameter]
    public T Step { get; set; }
    [Parameter]
    public T Min { get; set; }
    [Parameter]
    public Variant Variant { get; set; } = Variant.Text;
    [Parameter]
    public bool Clearable { get; set; } = false;
    [Parameter]
    public string? Format { get; set; }

    private CultureInfo? Culture { get; set; }
    private Type _underLyingType = GetUnderlyingType(typeof(T));
    private string? _displayedValue = string.Empty;

    protected override void OnInitialized()
    {
        base.OnInitialized();
        Culture = Currency.GetCurrency();

        if (!IsNumericType(_underLyingType))
        {
            throw new InvalidOperationException($"The type '{_underLyingType}' is not a numeric type.");
        }

        if (Step is null)
            Step = ConvertTo(1);
        if (Min is null)
            Min = (T)GetMinValue(_underLyingType);
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        Format = FormatPercentValue(Format);
        UpdateDisplayedValue();
    }

    private void OnValueChanged(T newValue)
    {
        if (EqualityComparer<T>.Default.Equals(newValue, ValueProperty))
            return;

        ValueProperty = newValue; // Update Value
        OnBindValueAfter(); // Send it to the server
        UpdateDisplayedValue(); // Update displayed value
    }

    private void UpdateDisplayedValue()
    {
        if (ValueProperty == null)
        {
            _displayedValue = string.Empty;
            return;
        }

        if (ValueProperty is IFormattable formattable)
            _displayedValue = formattable.ToString(Format, Culture);
        else
            _displayedValue = ValueProperty?.ToString();
    }

    private static bool IsNumericType(Type underLyingType)
    {
        if (underLyingType.IsEnum)
            return false;

        switch (Type.GetTypeCode(underLyingType))
        {
            case TypeCode.Byte:
            case TypeCode.SByte:
            case TypeCode.UInt16:
            case TypeCode.UInt32:
            case TypeCode.UInt64:
            case TypeCode.Int16:
            case TypeCode.Int32:
            case TypeCode.Int64:
            case TypeCode.Decimal:
            case TypeCode.Double:
            case TypeCode.Single:
                return true;
            default:
                return false;
        }
    }

    private static T ConvertTo(object value)
    {
        var type = typeof(T);
        var targetType = Nullable.GetUnderlyingType(type) ?? type;

        if (value == null || value == DBNull.Value)
        {
            return default;
        }

        return (T)Convert.ChangeType(value, targetType);
    }

    private static object GetMinValue(Type type) => type switch
    {
        Type t when t == typeof(float) => float.MinValue,
        Type t when t == typeof(double) => double.MinValue,
        Type t when t == typeof(decimal) => decimal.MinValue,
        Type t when t == typeof(int) => int.MinValue,
        Type t when t == typeof(long) => long.MinValue,
        Type t when t == typeof(sbyte) => sbyte.MinValue,
        Type t when t == typeof(byte) => byte.MinValue,
        Type t when t == typeof(short) => short.MinValue,
        Type t when t == typeof(ushort) => ushort.MinValue,
        Type t when t == typeof(uint) => uint.MinValue,
        Type t when t == typeof(ulong) => ulong.MinValue,
        _ => throw new ArgumentException($"Unsupported type {type}")
    };

    private static Type GetUnderlyingType(Type type) =>
    Nullable.GetUnderlyingType(type) ?? type;


}